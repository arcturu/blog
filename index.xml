<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>arcturu&#39;s posts on arcturu&#39;s posts</title>
    <link>http://blog.arcturu.com/</link>
    <description>Recent content in arcturu&#39;s posts on arcturu&#39;s posts</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-JP</language>
    <lastBuildDate>Sat, 30 Dec 2017 22:39:00 +0900</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>30秒ドローイングを9ヶ月続けた結果</title>
      <link>http://blog.arcturu.com/pose-2017/</link>
      <pubDate>Sat, 30 Dec 2017 22:39:00 +0900</pubDate>
      
      <guid>http://blog.arcturu.com/pose-2017/</guid>
      <description>

&lt;h2 id=&#34;はじめに&#34;&gt;はじめに&lt;/h2&gt;

&lt;p&gt;絵がうまくなりたいので自分なりにいろいろと練習をしているのですが、その一環として今年の4月から 30 秒ドローイングを始めました。以前にも散発的にやったことはあるのですがあまり身についている気がしなかったので、今回はちゃんと意味がある記録を取れるように条件を揃えて長期的にやってみました。&lt;/p&gt;

&lt;h2 id=&#34;30-秒ドローイングとは&#34;&gt;30 秒ドローイングとは&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://www.posemaniacs.com/thirtysecond&#34;&gt;30 秒ドローイング&lt;/a&gt; は Posemaniacs.com というポーズ集のサイトの中にある練習教材の一つです。タスクは 30 秒ごとにランダムに表示されるポーズを時間内に模写することです。これによって短時間で概形を掴む力や少ない線で表現する力が養われると言われています。&lt;/p&gt;

&lt;div class=&#34;ic&#34;&gt;
  &lt;a href=&#34;http://blog.arcturu.com/images/pose-2017/pomani.jpg&#34;&gt;
    &lt;img src=&#34;http://blog.arcturu.com/images/pose-2017/pomani.jpg&#34; alt=&#34;30 秒ドローイング&#34; /&gt;
  &lt;/a&gt;
  &lt;p class=&#34;caption&#34;&gt;(左) 初期画面 (右) タスク中の画面&lt;/p&gt;
&lt;/div&gt;


&lt;h2 id=&#34;練習メニュー&#34;&gt;練習メニュー&lt;/h2&gt;

&lt;p&gt;一日の練習メニューは &lt;code&gt;(30 秒の時間制限あり) 10 ポーズ + (時間制限なし) 3 ポーズ&lt;/code&gt; としました。具体的な数に根拠はありませんが、これくらいだとあわせて 10 分もかからないので気楽にできます。&lt;/p&gt;

&lt;h2 id=&#34;結果&#34;&gt;結果&lt;/h2&gt;

&lt;p&gt;以下に一月ずつ、初めの 20 体程度のポーズを示します。なお、上記練習メニューを正確に適用したのは7月17日以降で、それ以前のものについては時間制限が異なっていたり一日の枚数が違っていたりしています。また、時期によってペンも変わっているのでキャプションで補足しています。&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;ic&#34;&gt;
  &lt;a href=&#34;http://blog.arcturu.com/images/pose-2017/4.jpg&#34;&gt;
    &lt;img src=&#34;http://blog.arcturu.com/images/pose-2017/4.jpg&#34; alt=&#34;&#34; /&gt;
  &lt;/a&gt;
  &lt;p class=&#34;caption&#34;&gt;[4月, 90s-60s, ボールペン] &lt;/p&gt;
&lt;/div&gt;

&lt;div class=&#34;ic&#34;&gt;
  &lt;a href=&#34;http://blog.arcturu.com/images/pose-2017/5.jpg&#34;&gt;
    &lt;img src=&#34;http://blog.arcturu.com/images/pose-2017/5.jpg&#34; alt=&#34;&#34; /&gt;
  &lt;/a&gt;
  &lt;p class=&#34;caption&#34;&gt;[5月, 60s-30s, ボールペン]&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&#34;ic&#34;&gt;
  &lt;a href=&#34;http://blog.arcturu.com/images/pose-2017/6.jpg&#34;&gt;
    &lt;img src=&#34;http://blog.arcturu.com/images/pose-2017/6.jpg&#34; alt=&#34;&#34; /&gt;
  &lt;/a&gt;
  &lt;p class=&#34;caption&#34;&gt;[6月, 30s, シャーペン]&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&#34;ic&#34;&gt;
  &lt;a href=&#34;http://blog.arcturu.com/images/pose-2017/7.jpg&#34;&gt;
    &lt;img src=&#34;http://blog.arcturu.com/images/pose-2017/7.jpg&#34; alt=&#34;&#34; /&gt;
  &lt;/a&gt;
  &lt;p class=&#34;caption&#34;&gt;[7月, 30s, シャーペン]&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&#34;ic&#34;&gt;
  &lt;a href=&#34;http://blog.arcturu.com/images/pose-2017/8.jpg&#34;&gt;
    &lt;img src=&#34;http://blog.arcturu.com/images/pose-2017/8.jpg&#34; alt=&#34;&#34; /&gt;
  &lt;/a&gt;
  &lt;p class=&#34;caption&#34;&gt;[8月, 30s, シャーペン]&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&#34;ic&#34;&gt;
  &lt;a href=&#34;http://blog.arcturu.com/images/pose-2017/9.jpg&#34;&gt;
    &lt;img src=&#34;http://blog.arcturu.com/images/pose-2017/9.jpg&#34; alt=&#34;&#34; /&gt;
  &lt;/a&gt;
  &lt;p class=&#34;caption&#34;&gt;[9月, 30s, シャーペン]&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&#34;ic&#34;&gt;
  &lt;a href=&#34;http://blog.arcturu.com/images/pose-2017/10.jpg&#34;&gt;
    &lt;img src=&#34;http://blog.arcturu.com/images/pose-2017/10.jpg&#34; alt=&#34;&#34; /&gt;
  &lt;/a&gt;
  &lt;p class=&#34;caption&#34;&gt;[10月, 30s, シャーペン]&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&#34;ic&#34;&gt;
  &lt;a href=&#34;http://blog.arcturu.com/images/pose-2017/11.jpg&#34;&gt;
    &lt;img src=&#34;http://blog.arcturu.com/images/pose-2017/11.jpg&#34; alt=&#34;&#34; /&gt;
  &lt;/a&gt;
  &lt;p class=&#34;caption&#34;&gt;[11月, 30s, ボールペン]&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&#34;ic&#34;&gt;
  &lt;a href=&#34;http://blog.arcturu.com/images/pose-2017/12.jpg&#34;&gt;
    &lt;img src=&#34;http://blog.arcturu.com/images/pose-2017/12.jpg&#34; alt=&#34;&#34; /&gt;
  &lt;/a&gt;
  &lt;p class=&#34;caption&#34;&gt;[12月, 30s, ボールペン]&lt;/p&gt;
&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;各月の、実施日の数とかかった時間を以下のグラフに示します。8月以降はほぼ毎日やりました。&lt;/p&gt;

&lt;div class=&#34;ic&#34;&gt;
  &lt;a href=&#34;http://blog.arcturu.com/images/pose-2017/chart.png&#34;&gt;
    &lt;img src=&#34;http://blog.arcturu.com/images/pose-2017/chart.png&#34; alt=&#34;&#34; /&gt;
  &lt;/a&gt;
  &lt;p class=&#34;caption&#34;&gt;月ごとの実施回数 (右縦軸・青) と練習時間 (左縦軸・オレンジ)&lt;/p&gt;
&lt;/div&gt;


&lt;p&gt;4月1日から12月30日までの間に描いたポーズ数は 2390, 合計時間は約 21 時間です。&lt;/p&gt;

&lt;h2 id=&#34;感想-今後の展望&#34;&gt;感想・今後の展望&lt;/h2&gt;

&lt;p&gt;4月と12月を比べると迷い線は大幅に減少し、4月時点で 90 秒で取れていた程度の概形は 30 秒で取れるようになりました。迷い線の減少という点では6月にギャップがあるように感じますが、これは5月中旬にニコニコ動画で上手い人の動画を見て「パーツの上下を明確にしよう」と意識した結果だと思います。&lt;/p&gt;

&lt;p&gt;絵自体がうまくなったかというと……直接的な効果はこれと言って感じていません。その原因は二つ思いつきます。一つ目は、この練習を通して胸とお尻と脚まわりの関係が以前に比べてかなり理解できてきた実感があるのですが、絵を描く上での興味が現状そこに無いこと。二つ目はポーズを見て写すこととポーズを思いつくことは違うということです。後者は本質的で、この練習中に「ポーズを掴もう」ということより「局所的なパーツの上下関係の正しさを表現しよう」ということに集中してしまったのがよくなかったと思っています。&lt;/p&gt;

&lt;p&gt;これを受けて来年は&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;直接役に立つもの (手や衣類) を 30 秒ドローイング的な方法で練習する&lt;/li&gt;
&lt;li&gt;既存の作品からポーズと構図を学ぶ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ことを重点的にやっていこうと思います。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;30 秒ドローイング自体の上達は感じられた&lt;/li&gt;
&lt;li&gt;体つきを描く練習には良かったが興味から外れていて実感には繋がらなかった&lt;/li&gt;
&lt;li&gt;時間を決めて模写という枠組みはすばらしいので自分の問題範囲に適用していきたい&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>2017.09.03 (日) 武甲山山行記録</title>
      <link>http://blog.arcturu.com/2017-09-03-buko/</link>
      <pubDate>Tue, 05 Sep 2017 20:39:00 +0900</pubDate>
      
      <guid>http://blog.arcturu.com/2017-09-03-buko/</guid>
      <description>&lt;p&gt;9月3日に埼玉県の武甲山 (1304m) に登りました。程よい標高と石灰岩の採掘のため中腹から頂上にかけて大きく削られた山容が気になったため選びました。&lt;/p&gt;

&lt;div class=&#34;ic&#34;&gt;
  &lt;a href=&#34;http://blog.arcturu.com/images/2017-09-03-buko/IMGP5665.jpg&#34;&gt;
    &lt;img src=&#34;http://blog.arcturu.com/images/2017-09-03-buko/IMGP5665.jpg&#34; alt=&#34;photo&#34; /&gt;
  &lt;/a&gt;
  &lt;p class=&#34;caption&#34;&gt;秩父市役所から見た武甲山&lt;/p&gt;
&lt;/div&gt;


&lt;p&gt;池袋駅 7:05 発の西武池袋線快速急行長瀞行で横瀬駅へ。&lt;/p&gt;

&lt;div class=&#34;ic&#34;&gt;
  &lt;a href=&#34;http://blog.arcturu.com/images/2017-09-03-buko/IMG_1722.jpg&#34;&gt;
    &lt;img src=&#34;http://blog.arcturu.com/images/2017-09-03-buko/IMG_1722.jpg&#34; alt=&#34;photo&#34; /&gt;
  &lt;/a&gt;
  &lt;p class=&#34;caption&#34;&gt;西武池袋線池袋駅。西武の駅はどこも綺麗。&lt;/p&gt;
&lt;/div&gt;


&lt;p&gt;飯能駅を越えたあたりから山がちな地形になり、武甲山はどんなものかと周りの山と地図を見比べながら想像していましたが、芦ヶ久保駅付近のトンネルを抜けた後に見えた山容は予想以上に立派で感動しました。&lt;/p&gt;

&lt;p&gt;8:41 横瀬駅着。&lt;/p&gt;

&lt;div class=&#34;ic&#34;&gt;
  &lt;a href=&#34;http://blog.arcturu.com/images/2017-09-03-buko/IMGP5533.jpg&#34;&gt;
    &lt;img src=&#34;http://blog.arcturu.com/images/2017-09-03-buko/IMGP5533.jpg&#34; alt=&#34;photo&#34; /&gt;
  &lt;/a&gt;
  &lt;p class=&#34;caption&#34;&gt;横瀬駅から見た武甲山&lt;/p&gt;
&lt;/div&gt;


&lt;p&gt;駅から登山口までは 6 km ほどあり、徒歩だと 1 ~ 2 時間かかります。セメント工場地帯を歩くのもオツですがなにより体力に自信がないのでタクシーを使うことにしました。駅前にタクシー乗り場はありませんが電話すると数分で来てくれました。&lt;/p&gt;

&lt;p&gt;一の鳥居の手前の延命水で下車 (1810円)。&lt;/p&gt;

&lt;div class=&#34;ic&#34;&gt;
  &lt;a href=&#34;http://blog.arcturu.com/images/2017-09-03-buko/IMGP5542.jpg&#34;&gt;
    &lt;img src=&#34;http://blog.arcturu.com/images/2017-09-03-buko/IMGP5542.jpg&#34; alt=&#34;photo&#34; /&gt;
  &lt;/a&gt;
  &lt;p class=&#34;caption&#34;&gt;延命水&lt;/p&gt;
&lt;/div&gt;


&lt;p&gt;武甲山は石灰岩の山なのでミネラル豊富なんだろうな〜と思いながら飲みました。つめたくておいしかったです (水の味の違いがわからない)。&lt;/p&gt;

&lt;p&gt;ここから10分ほど歩くと一の鳥居に着きました。いよいよ登山道です。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.arcturu.com/images/2017-09-03-buko/IMGP5562.jpg&#34; class=&#34;ic&#34;&gt;
  &lt;img src=&#34;http://blog.arcturu.com/images/2017-09-03-buko/IMGP5562.jpg&#34; alt=&#34;photo&#34; /&gt;
&lt;/a&gt;

&lt;a href=&#34;http://blog.arcturu.com/images/2017-09-03-buko/IMGP5569.jpg&#34; class=&#34;ic&#34;&gt;
  &lt;img src=&#34;http://blog.arcturu.com/images/2017-09-03-buko/IMGP5569.jpg&#34; alt=&#34;photo&#34; /&gt;
&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;初めは生川沿いに登ります。途中、道を水が流れている箇所がありました。&lt;/p&gt;

&lt;a href=&#34;http://blog.arcturu.com/images/2017-09-03-buko/IMGP5579.jpg&#34; class=&#34;ic&#34;&gt;
  &lt;img src=&#34;http://blog.arcturu.com/images/2017-09-03-buko/IMGP5579.jpg&#34; alt=&#34;photo&#34; /&gt;
&lt;/a&gt;


&lt;p&gt;生川沿いを尾根筋にぶつかるまで歩いて不動滝に到着。&lt;/p&gt;

&lt;a href=&#34;http://blog.arcturu.com/images/2017-09-03-buko/IMGP5593.jpg&#34; class=&#34;ic&#34;&gt;
  &lt;img src=&#34;http://blog.arcturu.com/images/2017-09-03-buko/IMGP5593.jpg&#34; alt=&#34;photo&#34; /&gt;
&lt;/a&gt;


&lt;p&gt;滝の脇には水が入ったペットボトルがたくさん置いてありました。登山者が頂上まで運んでトイレの洗浄水の足しにするそうです。私は 2L のペットボトルを一つ持っていきました。&lt;/p&gt;

&lt;a href=&#34;http://blog.arcturu.com/images/2017-09-03-buko/IMGP5598.jpg&#34; class=&#34;ic&#34;&gt;
  &lt;img src=&#34;http://blog.arcturu.com/images/2017-09-03-buko/IMGP5598.jpg&#34; alt=&#34;photo&#34; /&gt;
&lt;/a&gt;


&lt;p&gt;枝ぶりがすごい大杉とかごろごろ転がっている石灰岩とかを見つつ頂上へ到着。展望スペースでは秩父一体から赤城山まで見えました。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.arcturu.com/images/2017-09-03-buko/IMGP5625.jpg&#34; class=&#34;ic&#34;&gt;
  &lt;img src=&#34;http://blog.arcturu.com/images/2017-09-03-buko/IMGP5625.jpg&#34; alt=&#34;photo&#34; /&gt;
&lt;/a&gt;

&lt;div class=&#34;ic&#34;&gt;
  &lt;a href=&#34;http://blog.arcturu.com/images/2017-09-03-buko/IMGP5634.jpg&#34;&gt;
    &lt;img src=&#34;http://blog.arcturu.com/images/2017-09-03-buko/IMGP5634.jpg&#34; alt=&#34;photo&#34; /&gt;
  &lt;/a&gt;
  &lt;p class=&#34;caption&#34;&gt;秩父一帯・中央やや右に赤城山&lt;/p&gt;
&lt;/div&gt;
&lt;/p&gt;

&lt;div class=&#34;ic&#34;&gt;
  &lt;a href=&#34;http://blog.arcturu.com/images/2017-09-03-buko/IMGP5627.jpg&#34;&gt;
    &lt;img src=&#34;http://blog.arcturu.com/images/2017-09-03-buko/IMGP5627.jpg&#34; alt=&#34;photo&#34; /&gt;
  &lt;/a&gt;
  &lt;p class=&#34;caption&#34;&gt;セメント工場&lt;/p&gt;
&lt;/div&gt;


&lt;p&gt;昼食にカップ麺を食べました。&lt;/p&gt;

&lt;a href=&#34;http://blog.arcturu.com/images/2017-09-03-buko/IMG_1744.jpg&#34; class=&#34;ic&#34;&gt;
  &lt;img src=&#34;http://blog.arcturu.com/images/2017-09-03-buko/IMG_1744.jpg&#34; alt=&#34;photo&#34; /&gt;
&lt;/a&gt;


&lt;p&gt;浦山口駅ルートで下山。登りのルートに比べると道が細くて下草が鬱陶しいものの展望があるポイントが多くて楽しいです。&lt;/p&gt;

&lt;a href=&#34;http://blog.arcturu.com/images/2017-09-03-buko/IMG_1759.jpg&#34; class=&#34;ic&#34;&gt;
  &lt;img src=&#34;http://blog.arcturu.com/images/2017-09-03-buko/IMG_1759.jpg&#34; alt=&#34;photo&#34; /&gt;
&lt;/a&gt;


&lt;p&gt;尾根を途中まで下ったあと、沢へつづら折りに下る道でかなり疲れました。辛くて写真を撮る余裕がありませんでした。&lt;/p&gt;

&lt;p&gt;ようやく着いた沢で手足を洗う。&lt;/p&gt;

&lt;a href=&#34;http://blog.arcturu.com/images/2017-09-03-buko/IMG_1763.jpg&#34; class=&#34;ic&#34;&gt;
  &lt;img src=&#34;http://blog.arcturu.com/images/2017-09-03-buko/IMG_1763.jpg&#34; alt=&#34;photo&#34; /&gt;
&lt;/a&gt;


&lt;p&gt;15:00 に浦山口駅側の林道に着き、その足で鍾乳洞へ。&lt;/p&gt;

&lt;a href=&#34;http://blog.arcturu.com/images/2017-09-03-buko/IMGP5662.jpg&#34; class=&#34;ic&#34;&gt;
  &lt;img src=&#34;http://blog.arcturu.com/images/2017-09-03-buko/IMGP5662.jpg&#34; alt=&#34;photo&#34; /&gt;
&lt;/a&gt;


&lt;p&gt;鍾乳洞内は、通路は狭く階段は急で疲れ切った脚には過酷でした。鍾乳洞近くの茶屋で冷やし甘酒とカレーパンを食べました (各300円)。&lt;/p&gt;

&lt;p&gt;浦山口駅から御花畑駅へ移動し、温泉！&lt;/p&gt;

&lt;a href=&#34;http://blog.arcturu.com/images/2017-09-03-buko/IMGP5677.jpg&#34; class=&#34;ic&#34;&gt;
  &lt;img src=&#34;http://blog.arcturu.com/images/2017-09-03-buko/IMGP5677.jpg&#34; alt=&#34;photo&#34; /&gt;
&lt;/a&gt;


&lt;p&gt;去年筑波山に登って以来まともに運動していなかったので非常に疲れました。&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;ic&#34;&gt;
  &lt;a href=&#34;http://blog.arcturu.com/images/2017-09-03-buko/s1.png&#34;&gt;
    &lt;img src=&#34;http://blog.arcturu.com/images/2017-09-03-buko/s1.png&#34; alt=&#34;photo&#34; /&gt;
  &lt;/a&gt;
  &lt;p class=&#34;caption&#34;&gt;今回のルート (右から左)&lt;/p&gt;
&lt;/div&gt;

[8:41 横瀬駅]〜延命水〜[9:20 一の鳥居]〜[11:50-13:15 武甲山山頂]〜[15:00 橋立林道終点]&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.seiburailway.jp/railways/hiking/tozan/bukouzan/index.html&#34;&gt;西武鉄道で行く ハイキングコース24選&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;このページのコースマップを参考にしました。標準コースタイム +45 分ほど。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>レイトレーサー開発日記 (1)</title>
      <link>http://blog.arcturu.com/writing-raytracer-1/</link>
      <pubDate>Fri, 12 May 2017 17:05:00 +0900</pubDate>
      
      <guid>http://blog.arcturu.com/writing-raytracer-1/</guid>
      <description>

&lt;p&gt;講義の課題でレイトレーサーを書いています。せっかくなので開発日記をつけることにしました。&lt;br&gt;
リポジトリは学期期間中に公開してはいけないということなので 8 月頃に出すつもりです。&lt;/p&gt;

&lt;h3 id=&#34;2017-04-27-n-a&#34;&gt;2017.04.27 [N/A]&lt;/h3&gt;

&lt;p&gt;名前 (sparkler) を考えてリポジトリを作った。&lt;/p&gt;

&lt;h3 id=&#34;2017-05-02-n-a&#34;&gt;2017.05.02 [N/A]&lt;/h3&gt;

&lt;p&gt;.obj のパーサーを書いた。&lt;br&gt;
v, vn, f だけ実装した。&lt;br&gt;
Makefile の書き方を調べていて GNU make のパターンルールを初めて明示的に知った。&lt;br&gt;
C++ で書いている。&lt;/p&gt;

&lt;h3 id=&#34;2017-05-05-19520-ms&#34;&gt;2017.05.05 [19520 ms]&lt;/h3&gt;

&lt;p&gt;動いた。&lt;br&gt;
(下図) 初めて出たもの&lt;br&gt;
&lt;a href=&#34;http://blog.arcturu.com/images/writing-raytracer/out1.png&#34; class=&#34;it&#34;&gt;
  &lt;img src=&#34;http://blog.arcturu.com/images/writing-raytracer/out1.png&#34; alt=&#34;first output&#34; style=&#34;max-width: 200px&#34; /&gt;
&lt;/a&gt;
&lt;/p&gt;

&lt;p&gt;カラフルなのは法線マップを RGB で表示しているため。&lt;br&gt;
レイトレーサーは絵を出すだけなら簡単。カメラ調整がやや難しかった。&lt;br&gt;
実装直後に走らせて真っ暗な画像しか出なかったときは悲しくなった (カメラ位置・方向の問題)。&lt;br&gt;
(下図) 動いていそうだったので lambertian と点光源でシェーディングしたらバグっていた。&lt;/p&gt;

&lt;a href=&#34;http://blog.arcturu.com/images/writing-raytracer/out5.png&#34; class=&#34;it&#34;&gt;
  &lt;img src=&#34;http://blog.arcturu.com/images/writing-raytracer/out5.png&#34; alt=&#34;first output&#34; style=&#34;max-width: 200px&#34; /&gt;
&lt;/a&gt;


&lt;p&gt;典型的な頂点法線補完のバグだった。&lt;br&gt;
(下図) 修正後&lt;/p&gt;

&lt;a href=&#34;http://blog.arcturu.com/images/writing-raytracer/out6.png&#34; class=&#34;it&#34;&gt;
  &lt;img src=&#34;http://blog.arcturu.com/images/writing-raytracer/out6.png&#34; alt=&#34;output&#34; style=&#34;max-width: 200px&#34; /&gt;
&lt;/a&gt;


&lt;p&gt;(下図) 角度調整後&lt;/p&gt;

&lt;a href=&#34;http://blog.arcturu.com/images/writing-raytracer/out8.png&#34; class=&#34;it&#34;&gt;
  &lt;img src=&#34;http://blog.arcturu.com/images/writing-raytracer/out8.png&#34; alt=&#34;output&#34; style=&#34;max-width: 200px&#34; /&gt;
&lt;/a&gt;


&lt;p&gt;今後このシーンをパフォーマンスの基準に使う。&lt;br&gt;
今日の結果は 19.52s! (time コマンドで計測) 高速化し甲斐があるとも言えるがびっくりするくらい遅い。&lt;br&gt;
ちなみに以降の結果は n 回の平均というわけではなく、適当に数回レンダリングしてみてだいたい平均っぽいな〜という値を取っている。&lt;/p&gt;

&lt;h3 id=&#34;2017-05-06-450-ms&#34;&gt;2017.05.06 [450 ms]&lt;/h3&gt;

&lt;p&gt;.obj の構文を拡張する形でカメラの情報をジオメトリ定義ファイルに持たせた。&lt;br&gt;
Bounding Volume Hierarchy (BVH) を実装した。[11000 ms]&lt;br&gt;
プロファイラをかけたところコピーコンストラクタが馬鹿にならないコストになっていた。&lt;br&gt;
(下図) intersectTriangle に Face と Ray を値渡ししている。&lt;/p&gt;

&lt;a href=&#34;http://blog.arcturu.com/images/writing-raytracer/profiler.png&#34; class=&#34;ic&#34;&gt;
  &lt;img src=&#34;http://blog.arcturu.com/images/writing-raytracer/profiler.png&#34; alt=&#34;profiler&#34; /&gt;
&lt;/a&gt;


&lt;p&gt;早すぎる最適化は悪と言っても、const 参照渡しは最初からやってもいいと思った。&lt;br&gt;
初めてプロファイラをまともに使ったけどとても便利だった。&lt;br&gt;
[6000 ms] コピーコスト削減&lt;br&gt;
[3500 ms] -O3&lt;br&gt;
[540 ms] 分割アルゴリズム改善 (今までは一番長い軸を半分に切っていたが、いろんな切り方を試して一番左右均等に切れるところで切るようにした)&lt;br&gt;
[450 ms] インライン化&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;2017-05-07-450-ms&#34;&gt;2017.05.07 [450 ms]&lt;/h3&gt;

&lt;p&gt;光源の設定を .obj ファイルに書けるようにした。&lt;br&gt;&lt;/p&gt;

&lt;h3 id=&#34;2017-05-09-280-ms&#34;&gt;2017.05.09 [280 ms]&lt;/h3&gt;

&lt;p&gt;コマンドライン出力をキレイにした。プロファイルっぽいものも内部で取るようにした。&lt;/p&gt;

&lt;p&gt;before&lt;/p&gt;

&lt;a href=&#34;http://blog.arcturu.com/images/writing-raytracer/cli-before.png&#34; class=&#34;it&#34;&gt;
  &lt;img src=&#34;http://blog.arcturu.com/images/writing-raytracer/cli-before.png&#34; alt=&#34;before&#34; style=&#34;max-width: 200px&#34; /&gt;
&lt;/a&gt;


&lt;p&gt;after&lt;/p&gt;

&lt;a href=&#34;http://blog.arcturu.com/images/writing-raytracer/cli-after.png&#34; class=&#34;it&#34;&gt;
  &lt;img src=&#34;http://blog.arcturu.com/images/writing-raytracer/cli-after.png&#34; alt=&#34;after&#34; style=&#34;max-width: 200px&#34; /&gt;
&lt;/a&gt;


&lt;p&gt;[380 ms] もっと const 参照&lt;br&gt;
[320 ms] Surface Area Heuristic (SAH) 実装&lt;br&gt;
[280 ms] 分割をやめる要素数をチューニング&lt;/p&gt;

&lt;h3 id=&#34;2017-05-11-81-ms&#34;&gt;2017.05.11 [81 ms]&lt;/h3&gt;

&lt;p&gt;頂点法線が設定されていない場合の面の法線の方向が逆だった、とかいう小さなバグを潰しつつ、&lt;/p&gt;

&lt;p&gt;[160 ms] intersectBox (BVH の各ノードボックスとレイの衝突判定) を手でループアンローリング（自作 3D ベクタ型の operator[] の実装が頭悪くて生のアクセスのほうが速かった）&lt;br&gt;
[100 ms] BVH の traverse を再帰からループにした（アセンブリ見てたらスタック退避コストが大きそうだったので）&lt;br&gt;
[81 ms] 不要なメモリ確保を抑制&lt;/p&gt;

&lt;p&gt;teapot のシーンで 1Mrps (Mega rays per second) をようやく超えられたのでうれしい。&lt;/p&gt;

&lt;p&gt;intersectBox 内を SIMD 化してみたが、[91 ms] と遅くなった。メモリアクセスコストに負けたか。&lt;/p&gt;

&lt;p&gt;rand() をシーケンシャルに配列に書き込むコード (下囲) を -O3 でビルドすると手元の環境では 128 M loops per sec ほどになるので、きっと 100M のオーダーは無理なんだろうと思う。10Mrps / thread くらいはいけるのかもしれない。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;

#define MS(x) std::chrono::duration_cast&amp;lt;std::chrono::milliseconds&amp;gt;(x).count()
typedef std::chrono::high_resolution_clock Clock;

int main() {
  const int N = 100000000;
  std::vector&amp;lt;int&amp;gt; xs;
  xs.resize(N);
  auto t1 = Clock::now();
  for (int i = 0; i &amp;lt; N; i++) {
    xs[i] = rand();
  }
  auto t2 = Clock::now();
  std::cout &amp;lt;&amp;lt; (double)N / MS(t2 - t1) * 1000 / 1000 / 1000 &amp;lt;&amp;lt; &amp;quot; (M loops per sec)&amp;quot; &amp;lt;&amp;lt; std::endl;
  // =&amp;gt; 127 Mlps
  return 0;
}

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Mac で krita をビルドする</title>
      <link>http://blog.arcturu.com/build-krita-on-mac/</link>
      <pubDate>Mon, 13 Mar 2017 17:05:00 +0900</pubDate>
      
      <guid>http://blog.arcturu.com/build-krita-on-mac/</guid>
      <description>

&lt;p&gt;macOS Sierra (10.12.3) 上で &lt;a href=&#34;https://krita.org/&#34;&gt;krita&lt;/a&gt; (3.1.88, git d007680) をビルドしました。krita のバイナリが mac 向けに安定版として公開されたのがバージョン 3.1 からということもあり、情報が少なく、はまりどころもいくつかあったので今後のためにビルド手順をまとめておきます。&lt;/p&gt;

&lt;h2 id=&#34;ビルド手順&#34;&gt;ビルド手順&lt;/h2&gt;

&lt;p&gt;作業ディレクトリは適宜読み替えて下さい。私の場合は &lt;code&gt;$HOME/Documents/repos/krita&lt;/code&gt;です。&lt;/p&gt;

&lt;h3 id=&#34;0-参考リンク&#34;&gt;0. 参考リンク&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.davidrevoy.com/article193/guide-building-krita-on-linux-for-cats&#34;&gt;Building Krita 3.0 on Linux for cats - David Revoy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://community.kde.org/Krita/linuxbuild&#34;&gt;Krita/linuxbuild - KDE Community Wiki&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;1-ソースのダウンロード&#34;&gt;1. ソースのダウンロード&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$ git clone https://anongit.kde.org/krita.git src
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-依存ライブラリのインストール&#34;&gt;2. 依存ライブラリのインストール&lt;/h3&gt;

&lt;p&gt;依存ライブラリの一覧は &lt;a href=&#34;https://github.com/KDE/krita/blob/master/README_PACKAGERS.md&#34;&gt;krita/README_PACKAGERS.md&lt;/a&gt; にあります。&lt;/p&gt;

&lt;p&gt;私の環境で追加インストールが必要だったライブラリは以下の通りです。(上 3 つのみ必須で残りは optional)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;KDE frameworks 5&lt;/li&gt;
&lt;li&gt;exiv2&lt;/li&gt;
&lt;li&gt;lcms2&lt;/li&gt;
&lt;li&gt;gsl&lt;/li&gt;
&lt;li&gt;libraw&lt;/li&gt;
&lt;li&gt;ocio&lt;/li&gt;
&lt;li&gt;poppler&lt;/li&gt;
&lt;li&gt;vc&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;vc 以外は homebrew パッケージがあるので homebrew でインストールし、vc はソースからビルドしました。&lt;/p&gt;

&lt;p&gt;KDE framework 5 のインストール (&lt;a href=&#34;https://github.com/haraldF/homebrew-kf5&#34;&gt;https://github.com/haraldF/homebrew-kf5&lt;/a&gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ brew tap haraldf/kf5
$ cd /usr/local/Homebrew/Library/Taps/haraldf/homebrew-kf5/
$ ./tools/install.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;その他ライブラリのインストール&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ brew install exiv2 lcms2 gsl libraw ocio
$ brew install poppler --with-qt5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;vc のインストール&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mkdir vc
$ cd vc
$ git clone https://github.com/VcDevel/Vc
$ mkdir build
$ cd build
$ cmake -DCMAKE_INSTALL_PREFIX=/opt/Vc -DBUILD_TESTING=OFF ../Vc/
$ make -j5
$ make install
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3-環境に応じた修正&#34;&gt;3. 環境に応じた修正&lt;/h3&gt;

&lt;p&gt;この状態で krita をビルドすると、私の環境では Qt と OpenEXR 周りのエラーが発生したので &lt;code&gt;src/CMakeLists.txt&lt;/code&gt; の末尾付近 (最後の &lt;code&gt;include_directories&lt;/code&gt; の出現の直後; 632 行目) に&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;include_directories(BEFORE /usr/local/opt/qt5/include)
include_directories(BEFORE /usr/local/include/OpenEXR)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を追加しました。&lt;/p&gt;

&lt;p&gt;一行目は Qt5 と Qt4 が両方ともインストールされている場合に誤って Qt4 のヘッダが読み込まれないようにするためで、二行目は &lt;code&gt;OpenEXR/half.h&lt;/code&gt; が &lt;code&gt;half.h&lt;/code&gt; としてインクルードされている部分があり手元の環境ではパスが通っていなかったためです。&lt;/p&gt;

&lt;h3 id=&#34;4-ビルド&#34;&gt;4. ビルド&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$ PATH=&amp;quot;/usr/local/opt/gettext/bin:$PATH&amp;quot; cmake -DCMAKE_INSTALL_PREFIX=$HOME/Documents/repos/krita/inst $HOME/Documents/repos/krita/src -DWITH_GMIC=ON -DCMAKE_BUILD_TYPE=RelWithDebInfo -DPRODUCTSET=ALL -DPACKAGERS_BUILD=ON -DBUILD_TESTING=OFF -DKDE4_BUILD_TESTS=OFF -DCMAKE_PREFIX_PATH=&amp;quot;/usr/local/Cellar/qt5/5.8.0_1/lib/cmake;/opt/Vc/lib/cmake&amp;quot;
$ make -j5
$ make -j5 install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ポイント&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;macOS では BSD 版 gettext が提供されており、GNU 版 gettext は brew でインストールしてもパスは通されないため明示的に指定&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-DCMAKE_INSTALL_PREFIX&lt;/code&gt; でインストール先ディレクトリを指定 (ということになっているが &lt;code&gt;krita.app&lt;/code&gt; は &lt;code&gt;/Application/KDE/&lt;/code&gt; 以下に配置される (なぜ ?))&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-DCMAKE_PREFIX_PATH&lt;/code&gt; で qt5 と vc のパスを指定 (まずこのオプションはなしで cmake してみて、パスが通っていなかったら付け加えればいい)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;5-実行&#34;&gt;5. 実行&lt;/h3&gt;

&lt;p&gt;ビルドできても実行までにやや手間がかかります。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;make install&lt;/code&gt; 終了時には &lt;code&gt;/Application/KDE/krita.app/&lt;/code&gt; 以下は次のようなファイル構成になっていると思います (私はそうでした)。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ tree
.
└── krita.app
    └── Contents
        ├── Info.plist
        ├── MacOS
        │   └── krita
        └── Resources
            └── krita_SRCS.icns
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;作業ディレクトリ &lt;code&gt;$HOME/Documents/repos/krita/&lt;/code&gt; 以下は次のようになりました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ tree -L 2
.
├── build
│   ├── CMakeCache.txt
│   ... (略)
│   └── plugins
├── inst
│   ├── etc
│   ├── lib
│   └── share
└── src
    ├── 3rdparty
    ... (略)
    └── winquirks
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;krita バイナリ配布版のディレクトリ構成を参考にリンクを張ります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ln -s $HOME/Documents/repos/krita/inst/lib /Applications/KDE/krita.app/Contents/Frameworks
$ ln -s $HOME/Documents/repos/krita/inst/lib/kritaplugins /Applications/KDE/krita.app/Contents/PlugIns
$ ln -s $HOME/Documents/repos/krita/inst/share/* /Applications/KDE/krita.app/Contents/Resources
$ ln -s $HOME/Documents/repos/krita/inst/share /Applications/KDE/krita.app/Contents
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(煩雑ですがミニマルなつもりです)&lt;/p&gt;

&lt;p&gt;&lt;code&gt;/Applications/KDE/krita.app/&lt;/code&gt; 以下は次のようになりました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ tree -L 4
.
└── krita.app
    └── Contents
        ├── Frameworks -&amp;gt; /Users/arcturu/Documents/repos/krita/inst/lib
        ├── Info.plist
        ├── MacOS
        │   └── krita
        ├── PlugIns -&amp;gt; /Users/arcturu/Documents/repos/krita/inst/lib/kritaplugins
        ├── Resources
        │   ├── applications -&amp;gt; /Users/arcturu/Documents/repos/krita/inst/share/applications
        │   ├── color -&amp;gt; /Users/arcturu/Documents/repos/krita/inst/share/color
        │   ├── color-schemes -&amp;gt; /Users/arcturu/Documents/repos/krita/inst/share/color-schemes
        │   ├── icons -&amp;gt; /Users/arcturu/Documents/repos/krita/inst/share/icons
        │   ├── krita -&amp;gt; /Users/arcturu/Documents/repos/krita/inst/share/krita
        │   ├── krita_SRCS.icns
        │   ├── kritaplugins -&amp;gt; /Users/arcturu/Documents/repos/krita/inst/share/kritaplugins
        │   └── metainfo -&amp;gt; /Users/arcturu/Documents/repos/krita/inst/share/metainfo
        └── share -&amp;gt; /Users/arcturu/Documents/repos/krita/inst/share
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これでアイコンをクリックするか、&lt;code&gt;$ /Applications/KDE/krita.app/Contents/MacOS/krita&lt;/code&gt; で起動します。&lt;/p&gt;

&lt;h2 id=&#34;openmp-について&#34;&gt;OpenMP について&lt;/h2&gt;

&lt;p&gt;Xcode についている clang (Apple LLVM version 8.0.0 (clang-800.0.42.1)) は現状 OpenMP に対応していません。OpenMP に対応させるには clang 3.7.0 以上か gcc 4.2 以上を使えばよいらしい (&lt;a href=&#34;http://qiita.com/r9y9/items/2e382887ee7e9fa0fb9f&#34;&gt;Macでclang+OpenMP 2016&lt;/a&gt;) ので gcc 6.2.0 で試しましたが、ビルドできませんでした。以下エラー抜粋です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[  2%] Building CXX object libs/widgetutils/CMakeFiles/kritawidgetutils.dir/KoResourcePaths.cpp.o
In file included from /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/Availability.h:184:0,
                 from /usr/local/opt/qt5/include/QtCore/qsystemdetection.h:236,
                 from /usr/local/opt/qt5/include/QtCore/qglobal.h:95,
                 from /usr/local/Cellar/qt5/5.8.0_1/lib/QtCore.framework/Headers/qscopedpointer.h:43,
                 from /usr/local/Cellar/qt5/5.8.0_1/lib/QtCore.framework/Headers/QScopedPointer:1,
                 from /Users/arcturu/Documents/repos/krita/src/libs/widgetutils/KoResourcePaths.h:21,
                 from /Users/arcturu/Documents/repos/krita/src/libs/widgetutils/KoResourcePaths.cpp:18:
/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.12.sdk/System/Library/Frameworks/CoreFoundation.framework/Headers/CFDateFormatter.h:53:34: error: &#39;introduced&#39; was not declared in this scope
     kCFISO8601DateFormatWithYear API_AVAILABLE(macosx(10.12), ios(10.0), watchos(3.0), tvos(10.0)) = (1UL &amp;lt;&amp;lt; 0),
                                  ^
/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.12.sdk/System/Library/Frameworks/CoreFoundation.framework/Headers/CFDateFormatter.h:53:34: error: &#39;introduced&#39; was not declared in this scope
     kCFISO8601DateFormatWithYear API_AVAILABLE(macosx(10.12), ios(10.0), watchos(3.0), tvos(10.0)) = (1UL &amp;lt;&amp;lt; 0),
                                  ^
/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.12.sdk/System/Library/Frameworks/CoreFoundation.framework/Headers/CFDateFormatter.h:53:34: error: &#39;introduced&#39; was not declared in this scope
     kCFISO8601DateFormatWithYear API_AVAILABLE(macosx(10.12), ios(10.0), watchos(3.0), tvos(10.0)) = (1UL &amp;lt;&amp;lt; 0),
                                  ^
/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.12.sdk/System/Library/Frameworks/CoreFoundation.framework/Headers/CFDateFormatter.h:53:34: error: &#39;introduced&#39; was not declared in this scope
     kCFISO8601DateFormatWithYear API_AVAILABLE(macosx(10.12), ios(10.0), watchos(3.0), tvos(10.0)) = (1UL &amp;lt;&amp;lt; 0),
                                  ^
/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.12.sdk/System/Library/Frameworks/CoreFoundation.framework/Headers/CFDateFormatter.h:54:35: error: &#39;introduced&#39; was not declared in this scope
     kCFISO8601DateFormatWithMonth API_AVAILABLE(macosx(10.12), ios(10.0), watchos(3.0), tvos(10.0)) = (1UL &amp;lt;&amp;lt; 1),
                                   ^
/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.12.sdk/System/Library/Frameworks/CoreFoundation.framework/Headers/CFDateFormatter.h:54:35: error: &#39;introduced&#39; was not declared in this scope
     kCFISO8601DateFormatWithMonth API_AVAILABLE(macosx(10.12), ios(10.0), watchos(3.0), tvos(10.0)) = (1UL &amp;lt;&amp;lt; 1),
                                   ^
/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.12.sdk/System/Library/Frameworks/CoreFoundation.framework/Headers/CFDateFormatter.h:54:35: error: &#39;introduced&#39; was not declared in this scope
     kCFISO8601DateFormatWithMonth API_AVAILABLE(macosx(10.12), ios(10.0), watchos(3.0), tvos(10.0)) = (1UL &amp;lt;&amp;lt; 1),
                                   ^
/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.12.sdk/System/Library/Frameworks/CoreFoundation.framework/Headers/CFDateFormatter.h:54:35: error: &#39;introduced&#39; was not declared in this scope
     kCFISO8601DateFormatWithMonth API_AVAILABLE(macosx(10.12), ios(10.0), watchos(3.0), tvos(10.0)) = (1UL &amp;lt;&amp;lt; 1),
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これは &lt;a href=&#34;https://github.com/LLNL/spack/issues/new&#34;&gt;cmake fails to build on macOS Sierra with GCC@6.2.0 · Issue #1847 · LLNL/spack&lt;/a&gt; と全く同じ問題だと思われます。clang では C と Objective-C のごった煮もビルドできるが gcc では問題があるらしい。gcc もランタイムを用意すれば Objectove-C コードをビルドできる (&lt;a href=&#34;http://qiita.com/ryochin/items/77100d42da4f8cfc8b8f&#34;&gt;CentOS6 に Objective-C 環境を整える - Qiita&lt;/a&gt;) そうなのでなんとかなりそうな気もしますが、新しい clang を使ったほうが簡単そうです。&lt;/p&gt;

&lt;p&gt;また、gcc では以下のような警告も出ます。(参考: &lt;a href=&#34;http://stackoverflow.com/questions/39865367/warning-section-textcoal-nt-is-deprecate-since-updating-to-mac-osx-sierra&#34;&gt;warning: section &amp;ldquo;__textcoal_n&amp;rdquo; is deprecate since updating to Mac OSX Sierra [duplicate]&lt;/a&gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[  1%] Building CXX object libs/version/CMakeFiles/kritaversion.dir/KritaVersionWrapper.cpp.o
/var/folders/ky/fzyv5cp90c16t7kxbq9c_hf80000gn/T//ccsMpiqj.s:3:11: warning: section &amp;quot;__textcoal_nt&amp;quot; is deprecated
        .section __TEXT,__textcoal_nt,coalesced,pure_instructions
                 ^      ~~~~~~~~~~~~~
/var/folders/ky/fzyv5cp90c16t7kxbq9c_hf80000gn/T//ccsMpiqj.s:3:11: note: change section name to &amp;quot;__text&amp;quot;
        .section __TEXT,__textcoal_nt,coalesced,pure_instructions
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;落とし穴&#34;&gt;落とし穴&lt;/h2&gt;

&lt;p&gt;ビルド手順 3 の &lt;code&gt;include_directories(BEFORE /usr/local/opt/qt5/include)&lt;/code&gt; を追加していない状態でビルドすると以下のようなエラーが出ました。原因は Qt4 のヘッダファイルが誤って読み込まれてしまい、Qt5 で新しく定義されたマクロが展開できなかったことだと考えられます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[  0%] Building CXX object libs/version/CMakeFiles/kritaversion.dir/KritaVersionWrapper.cpp.o
In file included from /usr/local/Cellar/qt5/5.8.0_1/lib/QtCore.framework/Headers/QString:1:0,
                 from /Users/arcturu/Documents/repos/krita/src/libs/version/KritaVersionWrapper.h:22,
                 from /Users/arcturu/Documents/repos/krita/src/libs/version/KritaVersionWrapper.cpp:18:
/usr/local/Cellar/qt5/5.8.0_1/lib/QtCore.framework/Headers/qstring.h:576:24: error: missing binary operator before token &amp;quot;(&amp;quot;
 #if QT_DEPRECATED_SINCE(5, 0)
                        ^
/usr/local/Cellar/qt5/5.8.0_1/lib/QtCore.framework/Headers/qstring.h:1052:24: error: missing binary operator before token &amp;quot;(&amp;quot;
 #if QT_DEPRECATED_SINCE(5, 3)
                        ^
/usr/local/Cellar/qt5/5.8.0_1/lib/QtCore.framework/Headers/qstring.h:1081:24: error: missing binary operator before token &amp;quot;(&amp;quot;
 #if QT_DEPRECATED_SINCE(5, 0)
                        ^
/usr/local/Cellar/qt5/5.8.0_1/lib/QtCore.framework/Headers/qstring.h:1481:24: error: missing binary operator before token &amp;quot;(&amp;quot;
 #if QT_DEPRECATED_SINCE(5, 0)
                        ^
/usr/local/Cellar/qt5/5.8.0_1/lib/QtCore.framework/Headers/qstring.h:1756:24: error: missing binary operator before token &amp;quot;(&amp;quot;
 #if QT_DEPRECATED_SINCE(5, 0)
                        ^
In file included from /usr/local/Cellar/qt5/5.8.0_1/lib/QtCore.framework/Headers/qstring.h:50:0,
                 from /usr/local/Cellar/qt5/5.8.0_1/lib/QtCore.framework/Headers/QString:1,
                 from /Users/arcturu/Documents/repos/krita/src/libs/version/KritaVersionWrapper.h:22,
                 from /Users/arcturu/Documents/repos/krita/src/libs/version/KritaVersionWrapper.cpp:18:
/usr/local/Cellar/qt5/5.8.0_1/lib/QtCore.framework/Headers/qrefcount.h:54:21: error: expected &#39;;&#39; at end of member declaration
     inline bool ref() Q_DECL_NOTHROW {
                     ^
/usr/local/Cellar/qt5/5.8.0_1/lib/QtCore.framework/Headers/qrefcount.h:54:23: error: &#39;Q_DECL_NOTHROW&#39; does not name a type
     inline bool ref() Q_DECL_NOTHROW {
                       ^~~~~~~~~~~~~~
/usr/local/Cellar/qt5/5.8.0_1/lib/QtCore.framework/Headers/qrefcount.h:65:23: error: expected &#39;;&#39; at end of member declaration
     inline bool deref() Q_DECL_NOTHROW {
                       ^
/usr/local/Cellar/qt5/5.8.0_1/lib/QtCore.framework/Headers/qrefcount.h:65:25: error: &#39;Q_DECL_NOTHROW&#39; does not name a type
     inline bool deref() Q_DECL_NOTHROW {
                         ^~~~~~~~~~~~~~
                              ^
(中略)


/Users/arcturu/Documents/repos/krita/src/libs/version/KritaVersionWrapper.cpp:30:30: error: &#39;const struct QStaticStringData&amp;lt;7&amp;gt;&#39; has no member named &#39;data_ptr&#39;; did you mean &#39;data&#39;?
         QString gitVersion = QStringLiteral(KRITA_GIT_SHA1_STRING);
                              ^
/Users/arcturu/Documents/repos/krita/src/libs/version/KritaVersionWrapper.cpp: In lambda function:
/Users/arcturu/Documents/repos/krita/src/libs/version/KritaVersionWrapper.cpp:31:19: error: &#39;QStringData&#39; was not declared in this scope
         version = QStringLiteral(&amp;quot;%1 (git %2)&amp;quot;).arg(kritaVersion, gitVersion);
                   ^
/Users/arcturu/Documents/repos/krita/src/libs/version/KritaVersionWrapper.cpp:31:19: error: braces around scalar initializer for type &#39;qunicodechar {aka char16_t}&#39;
         version = QStringLiteral(&amp;quot;%1 (git %2)&amp;quot;).arg(kritaVersion, gitVersion);
                   ^
/Users/arcturu/Documents/repos/krita/src/libs/version/KritaVersionWrapper.cpp:31:19: error: &#39;const struct QStaticStringData&amp;lt;11&amp;gt;&#39; has no member named &#39;data_ptr&#39;; did you mean &#39;data&#39;?
         version = QStringLiteral(&amp;quot;%1 (git %2)&amp;quot;).arg(kritaVersion, gitVersion);
                   ^
At global scope:
cc1plus: warning: unrecognized command line option &#39;-Wno-deprecated-register&#39;
cc1plus: warning: unrecognized command line option &#39;-Wno-macro-redefined&#39;
make[2]: *** [libs/version/CMakeFiles/kritaversion.dir/KritaVersionWrapper.cpp.o] Error 1
make[1]: *** [libs/version/CMakeFiles/kritaversion.dir/all] Error 2
make: *** [all] Error 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;OpenEXR/half.h&lt;/code&gt; へのパスが通っていないときは以下のようなエラーが出ます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Scanning dependencies of target kritapigment
[  5%] Building CXX object libs/pigment/CMakeFiles/kritapigment.dir/DebugPigment.cpp.o
[  5%] Building CXX object libs/pigment/CMakeFiles/kritapigment.dir/KoBasicHistogramProducers.cpp.o
/Users/arcturu/Documents/repos/krita/src/libs/pigment/KoBasicHistogramProducers.cpp:26:10: fatal error:
      &#39;half.h&#39; file not found
#include &amp;lt;half.h&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;/Applications/KDE/krita.app/&lt;/code&gt; 以下のディレクトリ構成は重要で、例えば &lt;code&gt;/Applications/KDE/krita.app/PlugIns/&lt;/code&gt; がないと &lt;code&gt;The Calligra LittleCMS color management plugin is not installed. Krita will quit now.&lt;/code&gt; というポップアップが出て強制終了します。&lt;/p&gt;

&lt;a href=&#34;http://blog.arcturu.com/images/2017-03-13/lcms-error.png&#34; class=&#34;ic&#34;&gt;
  &lt;img src=&#34;http://blog.arcturu.com/images/2017-03-13/lcms-error.png&#34; alt=&#34;The Calligra LittleCMS color management plugin is not installed. Krita will quit now.&#34; /&gt;
&lt;/a&gt;

</description>
    </item>
    
    <item>
      <title>twoproc（的な何か）でインオーダパイプラインコアを書く</title>
      <link>http://blog.arcturu.com/2015/12/17/276/</link>
      <pubDate>Wed, 16 Dec 2015 16:25:42 +0000</pubDate>
      
      <guid>http://blog.arcturu.com/2015/12/17/276/</guid>
      <description>

&lt;p&gt;これは&lt;a href=&#34;http://www.adventar.org/calendars/1056&#34;&gt;CPU実験 Advent Calendar 2015&lt;/a&gt;の17日目の記事です。&lt;/p&gt;

&lt;p&gt;CPU 実験の 1st アーキテクチャとして実装したインオーダパイプラインコアについて&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;構成&lt;/li&gt;
&lt;li&gt;ハマったポイント&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;を中心にまとめました。&lt;/p&gt;

&lt;p&gt;完全なソースコードは &lt;a href=&#34;https://github.com/arcturu/CarteletV1&#34;&gt;https://github.com/arcturu/CarteletV1&lt;/a&gt; にあります。&lt;/p&gt;

&lt;h2 id=&#34;twoprocとは&#34;&gt;twoprocとは&lt;/h2&gt;

&lt;p&gt;twoproc とは VHDL のデザイン手法のひとつで、適当に書くとしっちゃかめっちゃかになりがちな VHDL コードの構造化と、バグの予防に非常に役立ちます。&lt;/p&gt;

&lt;p&gt;詳細については &lt;a href=&#34;http://wasabiz.hatenablog.com/entry/2015/03/18/173921&#34;&gt;twoprocの書き方&lt;/a&gt; と、リンク先ブログ内にあるスライドが非常にわかりやすいのでそちらを参照して下さい。&lt;/p&gt;

&lt;p&gt;僕が感じた twoproc を採用する直接的なメリットとしては&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;意図しないラッチが発生しにくい&lt;/li&gt;
&lt;li&gt;ラッチを消しやすい&lt;/li&gt;
&lt;li&gt;構造化されてわかりやすい (twoproc のメリットというよりも record 文のメリット)&lt;/li&gt;
&lt;li&gt;データの流れが理解しやすい&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;などがあります。&lt;/p&gt;

&lt;h2 id=&#34;パイプライン構成&#34;&gt;パイプライン構成&lt;/h2&gt;

&lt;p&gt;&lt;a rel=&#34;nofollow&#34; href=&#34;http://www.amazon.co.jp/gp/product/B00UJ42A0K/ref=as_li_ss_tl?ie=UTF8&amp;#038;camp=247&amp;#038;creative=7399&amp;#038;creativeASIN=B00UJ42A0K&amp;#038;linkCode=as2&amp;#038;tag=arcturu-22&#34;&gt;パタヘネ&lt;/a&gt;&lt;img src=&#34;http://ir-jp.amazon-adsystem.com/e/ir?t=arcturu-22&amp;#038;l=as2&amp;#038;o=9&amp;#038;a=B00UJ42A0K&#34; width=&#34;1&#34; height=&#34;1&#34; border=&#34;0&#34; alt=&#34;&#34; style=&#34;border:none !important; margin:0px !important;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;を参考に以下の四段構成にしました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;命令フェッチ (Instruction Fetch: IF)&lt;/li&gt;
&lt;li&gt;デコード・レジスタアクセス (Instruction Decode / Register Read: ID)&lt;/li&gt;
&lt;li&gt;実行 (Execute: EX)&lt;/li&gt;
&lt;li&gt;レジスタ書き戻し (Write Back: WB)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;パタヘネでは五段目としてメモリアクセスフェーズがありますが、Cartelet v1 (1st アーキテクチャ) ではメモリリード命令も実行フェーズ内で完結させるようにしました。このようにした理由は、キャッシュメモリをつけるとヒット時とミス時でアクセスに必要なクロック数が変わり、それを違うパイプライン段で受けるのがしんどかったためです。&lt;/p&gt;

&lt;p&gt;Cartelet v1 ではリードに 0 クロックしかかからないフリップフロップのキャッシュを 16 個つけていますが、実行フェーズでの挙動は&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;キャッシュミス時 =&amp;gt; 3 clk バブルが入る (4 clk で実行終了)&lt;/li&gt;
&lt;li&gt;キャッシュヒット時 =&amp;gt; バブルは入らない (1 clk で実行終了)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;となります。&lt;/p&gt;

&lt;h3 id=&#34;パイプライン化の方法&#34;&gt;パイプライン化の方法&lt;/h3&gt;

&lt;p&gt;パイプラインという概念は本や講義では当たり前のように出てきて、「それ名前つけるほどのものでもなくね？」という感じがしつつも、実際に VHDL でどう書くのかと言われると少し詰まってしまうのではないでしょうか。僕はそうでした。&lt;/p&gt;

&lt;a href=&#34;http://blog.arcturu.com/images/2015-12-17/pipeline.png&#34; class=&#34;ic&#34;&gt;
  &lt;img src=&#34;http://blog.arcturu.com/images/2015-12-17/pipeline.png&#34; alt=&#34;pipeline&#34; /&gt;
&lt;/a&gt;


&lt;p&gt;こんな感じのパイプラインの概念図はよく目にしますが、以下の Cartelet v1 の cpu.vhd の抜粋と見比べるとほぼそのまま対応する部分があることがわかると思います。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/arcturu/CarteletV1/blob/master/cpu.vhd&#34;&gt;https://github.com/arcturu/CarteletV1/blob/master/cpu.vhd&lt;/a&gt;&lt;/p&gt;

&lt;pre class=&#34;lang:default decode:true &#34; title=&#34;cpu.vhd&#34; &gt;library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

use work.types.all;

entity CPU is
    port (
        clk : in std_logic;
        rst : in std_logic;
        cpu_in : in cpu_in_type;
        cpu_out : out cpu_out_type);
end entity;

architecture struct of CPU is
    type fetch_readreg_reg_type is record
        pc : std_logic_vector ((PMEM_ADDR_WIDTH - 1) downto 0);
        fetched : std_logic;
        data : std_logic_vector (31 downto 0);
    end record;
    type readreg_ex_reg_type is record
        pc : std_logic_vector ((PMEM_ADDR_WIDTH - 1) downto 0);
        data : std_logic_vector (31 downto 0);
        ex_op : std_logic_vector (5 downto 0);
        dest_num : std_logic_vector (4 downto 0);
        dest_value : std_logic_vector (31 downto 0);
        lhs_num : std_logic_vector (4 downto 0);
        lhs_value : std_logic_vector (31 downto 0);
        rhs_num : std_logic_vector (4 downto 0);
        rhs_value : std_logic_vector (31 downto 0);
        imm : std_logic_vector (15 downto 0);
    end record;
    type ex_wb_reg_type is record
        pc : std_logic_vector ((PMEM_ADDR_WIDTH - 1) downto 0);
        dest_num : std_logic_vector (4 downto 0);
        data_source : data_source_type;
        sram_state : sram_state_type;
        sram_addr : std_logic_vector (19 downto 0);
        sram_data_to_be_written : std_logic_vector (31 downto 0);
        write : std_logic;
        data : std_logic_vector (31 downto 0);
        next_pc : std_logic_vector ((PMEM_ADDR_WIDTH - 1) downto 0);
    end record;
    type wb_mem_reg_type is record
        sram_state : sram_state_type;
        sram_data_to_be_written : std_logic_vector (31 downto 0);
        dest_num : std_logic_vector (4 downto 0);
    end record;
    -- (cache などの type 宣言)
    type reg_type is record
        sram_cache : sram_cache_type;
        sram_in_buf : std_logic_vector (31 downto 0);
        pc : std_logic_vector ((PMEM_ADDR_WIDTH - 1) downto 0);
        bubble_counter : std_logic_vector (3 downto 0);
        repeat : std_logic;
        load_size : std_logic_vector ((PMEM_ADDR_WIDTH - 1) downto 0);
        load_counter : std_logic_vector ((PMEM_ADDR_WIDTH - 1) downto 0);
        forwarder_file : forwarder_file_type;
        fetch_counter : std_logic_vector (3 downto 0);
        fetch_readreg_reg2 : fetch_readreg_reg_type;
        readreg_ex_reg : readreg_ex_reg_type;
        ex_wb_reg : ex_wb_reg_type;
        wb_mem_reg : wb_mem_reg_type;
        regs : registers_type;
        fregs : registers_type;
        fpcond : std_logic;
        alu_in : alu_in_type;
        fpu_in : fpu_in_type;
        cpu_state : cpu_state_type;
    end record;
    constant reg_init : reg_type := (
        sram_cache =&amp;gt; (others =&amp;gt; (
            data =&amp;gt; (others =&amp;gt; &#39;0&#39;),
            valid =&amp;gt; &#39;0&#39;,
            tag =&amp;gt; (others =&amp;gt; &#39;0&#39;))),
        -- (略)
        cpu_state =&amp;gt; ready);
begin
--    pmem : dmem_sim port map (
    pmem : mem port map (
        clka =&amp;gt; clk,
        wea =&amp;gt; pmem_we,
        addra =&amp;gt; pmem_addr,
        dina =&amp;gt; pmem_din,
        douta =&amp;gt; pmem_dout);

    alu_0 : alu port map (
        clk =&amp;gt; clk,
        rst =&amp;gt; &#39;0&#39;,
        alu_in =&amp;gt; alu_in,
        alu_out =&amp;gt; alu_out);

    fpu_0 : fpu port map (
        clk =&amp;gt; clk,
        rst =&amp;gt; &#39;0&#39;,
        fpu_in =&amp;gt; fpu_in,
        fpu_out =&amp;gt; fpu_out);


    comb : process (cpu_in, r, pmem_dout, alu_out, fpu_out)
        variable v : reg_type;
        -- (略: reg_type に入れる程でもない(次のクロックまで記憶する必要が無い) variables)
    begin
        v := r;
        cpu_ex_rst8 := &#39;0&#39;;
        cpu_ex_go := &#39;0&#39;;
        -- (略: variable の初期化)
        inst := (others =&amp;gt; &#39;0&#39;);
        case r.cpu_state is
-- この辺はプログラムローダ ----------------------------------------------------------------------
            when ready =&amp;gt;
                -- (略: プログラムローダと実行モードの切り替えをしている)
            when ploading =&amp;gt;
                -- (略: プログラムメモリにプログラムを書き込む)
            when dloading =&amp;gt;
                -- (略: データメモリ(SRAM) に .data 領域のデータを書き込む)
            when running =&amp;gt;
                pmem_we &amp;lt;= (others =&amp;gt; &#39;0&#39;);

                v_forwarder := r.forwarder_file(0);
-- write back -----------------------------------------------------------------------------
                if r.repeat = &#39;0&#39; then
                    v.forwarder_file(1) := r.forwarder_file(0);
                    if r.ex_wb_reg.write = &#39;1&#39; then
                        case r.ex_wb_reg.data_source is
                            when src_alu =&amp;gt;
                                tmp_data := alu_out.data;
                                v.regs (to_integer(unsigned(r.ex_wb_reg.dest_num))) := tmp_data;
                                v.forwarder_file(0).floating := &#39;0&#39;;
                                v_forwarder.floating := &#39;0&#39;;
                           -- (略: alu 以外の演算器からの出力データを処理
                        end case;
                        v.forwarder_file(0).reg_num := r.ex_wb_reg.dest_num;
                        v_forwarder.reg_num := r.ex_wb_reg.dest_num;
                        v.forwarder_file(0).valid := &#39;1&#39;;
                        v_forwarder.valid := &#39;1&#39;;
                        v.forwarder_file(0).value := tmp_data;
                        v_forwarder.value := tmp_data;
                    elsif v.repeat = &#39;0&#39; then
                        v.forwarder_file(0).valid := &#39;0&#39;;
                        v_forwarder.valid := &#39;0&#39;;
                    end if;
                end if;

-- execute -------------------------------------------------------------------------------------
                --      forwarding
                ex_lhs_value := r.readreg_ex_reg.lhs_value;
                ex_rhs_value := r.readreg_ex_reg.rhs_value;
                ex_dest_value := r.readreg_ex_reg.dest_value;

                -- (略: フォワーディングされてきたデータを ex_lhs_value などに入れる)

                flush_read := &#39;0&#39;;
                if r.bubble_counter = x&#34;0&#34; then
                    v.ex_wb_reg.pc := r.readreg_ex_reg.pc;
                    v.ex_wb_reg.write := &#39;0&#39;;
                    v.ex_wb_reg.sram_state := idle;
                end if;
                case r.readreg_ex_reg.ex_op is
                    when OP_ADD =&amp;gt;
                        v.ex_wb_reg.dest_num := r.readreg_ex_reg.dest_num;
                        v.ex_wb_reg.write := &#39;1&#39;;
                        v.ex_wb_reg.data_source := src_alu;
                        v.alu_in.command := ALU_ADD;
                        v.alu_in.lhs := ex_lhs_value;
                        v.alu_in.rhs := ex_rhs_value;
                    when OP_ADDI =&amp;gt;
                    -- (略: 個々の命令の処理)
                    when others =&amp;gt;
                end case;
                if v.bubble_counter = x&#34;0&#34; and flush_read = &#39;0&#39; and v.repeat = &#39;0&#39; and no_fetch = &#39;0&#39; then
                    v.pc := std_logic_vector(unsigned(v.pc) + 1); -- pc すすめる
                end if;

-- read and decode -----------------------------------------------------------------------------
                -- (略: デコードして v.readreg_ex_reg を更新)

-- fetch ---------------------------------------------------------------------------------------
                v_pmem_addr := v.pc;
                if v.bubble_counter = x&#34;0&#34; and flush_read = &#39;0&#39; and v.repeat = &#39;0&#39; and no_fetch = &#39;0&#39; then -- v なのは意図的です
--                    v.fetch_readreg_reg2.pc := r.fetch_readreg_reg.pc;
                    v.fetch_readreg_reg2.pc := v.pc;
                    v.fetch_readreg_reg2.fetched := &#39;0&#39;;
                end if;

                v.sram_in_buf := cpu_in.sram_din;
            when others =&amp;gt;
                pmem_we &amp;lt;= (others =&amp;gt; &#39;0&#39;);
        end case;

-- 計算結果を出力 -------------------------------------------------------------------------------
        cpu_out.ex_pop8 &amp;lt;= cpu_ex_pop8;
        cpu_out.sram_we &amp;lt;= cpu_ex_sram_we;
        cpu_out.sram_addr &amp;lt;= cpu_ex_sram_addr;
        cpu_out.sram_dout &amp;lt;= cpu_ex_sram_dout;
        cpu_out.ex_rst8 &amp;lt;= cpu_ex_rst8;
        cpu_out.state &amp;lt;= r.cpu_state;
        cpu_out.ex_go &amp;lt;= cpu_ex_go;
        cpu_out.ex_data &amp;lt;= cpu_ex_data;
        pmem_addr &amp;lt;= v_pmem_addr;
        pmem_din &amp;lt;= v_pmem_din;
        fpu_in &amp;lt;= v.fpu_in;
        alu_in &amp;lt;= v.alu_in;
        v.regs (0) := (others =&amp;gt; &#39;0&#39;); -- must be zero
        rin &amp;lt;= v;
    end process;
    reg : process (clk)
    begin
        if rising_edge(clk) then
            r &amp;lt;= rin;
        end if;
    end process;
end struct;&lt;/pre&gt;

&lt;p&gt;ここで、データが流れる順序としては IF, ID, EX, WB なのにコード中では WB, EX, ID, IF の順に書いてあるのはこうすることでフォワーディングが自然に書ける（WB に来た計算済みデータを variable として EX に流し、EX のオペランドの値としてつかえるようにすればフォワーディングできる）ためです。ただあんまりステージ間を跨いだ variable をつかいまくるとそれがクリティカルパスになり、何のためにパイプライン化しているのかわからなくなってくるので、ステージを跨いだ variable は可能な限り減らさないと周波数が上がりません。Cartelet v1 ではフォワーディング周りがクリティカルパスになっています。&lt;/p&gt;

&lt;p&gt;また、CPU モジュールから ALU, FPU などは切り出していますが、ここへの入力には v.alu_in や v.fpu_in という variable をつないでいます。v.alu_in などは EX フェーズで変更され、そのクロックのうちに ALU に入れたいからです。これを v.alu_in でなく r.alu_in とすると、EX フェーズで v.alu_in を変更した次のクロックで ALU にデータが入る事になり、1クロック遅れます。そもそも reg_type の中に alu_in などを入れずに、ALU の入力に直に EX フェーズで入れてしまえばいいような気がしますが、それをすると ALU を使わない命令 (fadd など) 時にも ALU の入力をいれる事を忘れがちです。これを忘れると ALU の入力にはラッチが生える（クロックの立ち上がり時にデータを拾い、次のクロックの立ち上がり時まで記憶するフリップフロップ動作ではなく、クロックの立ち上がり後も、Hi の間はデータの変化を拾い続けるラッチ動作になる）ことで xst (合成ツール) のタイミング制約判定が甘くなり？本来あるべきクリティカルパスが見えなくなる事があります（このあたりの原理はよく理解していませんが問題が起きることは確かです）。ALU の場合はとくに問題になりませんが、パスが伸びがちな FPU との接続部分にラッチが生えるとクリティカルなバグになることがあります。僕は FPU をつなぐときにラッチができていたのが原因で、マンデルブロ集合を描くサンプルプログラムを実行した時に、実行するたびに結果が変わった（しかも破壊されている）ことがあります。&lt;/p&gt;

&lt;p&gt;〜破壊された mandelbrot の例〜&lt;/p&gt;

&lt;a href=&#34;http://blog.arcturu.com/images/2015-12-17/mandelbrot.png&#34; class=&#34;ic&#34;&gt;
  &lt;img src=&#34;http://blog.arcturu.com/images/2015-12-17/mandelbrot.png&#34; alt=&#34;broken mandelbrot&#34; /&gt;
&lt;/a&gt;


&lt;p&gt;ラッチへの対処法としては、signal への代入が全場合分けで尽くされているかどうかをチェックすることと、ラッチができると xst が&lt;/p&gt;

&lt;p&gt;&amp;#8220;WARNING:Xst:737 &amp;#8211; Found n-bit latch for signal &lt;name&gt;.&amp;#8221;&lt;/p&gt;

&lt;p&gt;のような warning を出すのでこれを見落とさずにしっかり直すことに尽きます。コードが長くなってくると数百個の warning が出ることがザラにあるので warning への感度がさがりますが、ラッチだけは絶対に消すように心がけています。&lt;/p&gt;

&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;インオーダパイプラインでキャッシュ付きのメモリをうまいことするのは難しい&lt;/li&gt;
&lt;li&gt;データパスと逆向きに記述するとうまくいく&lt;/li&gt;
&lt;li&gt;ラッチは消す&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Cartelet v1 のスペックは 39億命令 88MHz 102.7s (IPC 0.43) です。&lt;/p&gt;

&lt;p&gt;今は OoO superscalar な 2nd アーキテクチャ Cartelet 2 を書いています。メモリ周りと分岐を上手いことしたいと思います。&lt;/p&gt;

&lt;h3 id=&#34;おまけ&#34;&gt;おまけ&lt;/h3&gt;

&lt;p&gt;（左）フォワーディングのバグによって壊れたレイトレ画像&lt;/p&gt;

&lt;p&gt;（右）正しい画像&lt;/p&gt;

&lt;div class=&#34;clearfix&#34;&gt;
  &lt;a href=&#34;http://blog.arcturu.com/images/2015-12-17/min-rt6.png&#34;&gt;&lt;img src=&#34;http://blog.arcturu.com/images/2015-12-17/min-rt6.png&#34; width=&#34;300px&#34; alt=&#34;min-rt6&#34; /&gt;&lt;/a&gt;
  &lt;a href=&#34;http://blog.arcturu.com/images/2015-12-17/min-rt.png&#34;&gt;&lt;img src=&#34;http://blog.arcturu.com/images/2015-12-17/min-rt.png&#34; width=&#34;300px&#34; alt=&#34;min-rt&#34; /&gt;&lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;一見まともそうですが、ゴミがついていたりグラデーションが変だったりします。&lt;/p&gt;

&lt;p&gt;原因を調べた所、出力ユニットのキューがあふれた場合に実行がストールするとフォワーディングが壊れて RAW ハザードが起きていたようでした。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Node.js で類似文字列検索 twitter bot をつくる</title>
      <link>http://blog.arcturu.com/2015/02/06/256/</link>
      <pubDate>Fri, 06 Feb 2015 08:04:37 +0000</pubDate>
      
      <guid>http://blog.arcturu.com/2015/02/06/256/</guid>
      <description>

&lt;p&gt;「きんいろモザイク中に登場する台詞と類似したツイートを検知して、類似部分の台詞とメタデータをリプライするボット」を作りました。&lt;a href=&#34;http://twitter.com/kinmoza_quotes&#34;&gt;@kinmoza_quotes&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;アルゴリズムと twitter streaming api / REST api の使い方を簡単にまとめておきます。&lt;/p&gt;

&lt;h3 id=&#34;類似文字列検索アルゴリズム&#34;&gt;類似文字列検索アルゴリズム&lt;/h3&gt;

&lt;p&gt;類似文字列検索のライブラリとしては &lt;a href=&#34;http://www.chokkan.org/software/simstring/index.html.ja&#34;&gt;SimString&lt;/a&gt; などいろいろあるようですが、今回のケースでは辞書サイズはどんなに大きくても10000レコードくらいで収まりそうであることと、簡単な方法でも十分速そうなことから勉強も兼ねて自分で書くことにしました。&lt;/p&gt;

&lt;p&gt;文字列同士の類似度の評価には「それぞれの文字列の bi-gram をとって集合としての類似度を計算し、それを文字列の類似度とする」方針を取りました。&lt;/p&gt;

&lt;pre&gt;str1 = &#39;hogefuga&#39;; -- bi-gramize --&gt; {ho, og, ge, ef, fu, ug, ga}
str2 = &#39;abcdef&#39;;   -- bi-gramize --&gt; {ab, bc, cd, de, ef}

{ho, og, ge, ef, fu, ug, ga} AND {ab, bc, cd, de, ef}
 = {ef}

{ho, og, ge, ef, fu, ug, ga} OR {ab, bc, cd, de, ef}
 = {ho, og, ge, ef, fu, ug, ga, ab, bc, cd, de}
&lt;/pre&gt;

&lt;p&gt;ここで&lt;/p&gt;

&lt;p&gt;(bi-gram の積集合の要素数) / (bi-gram の和集合の要素数) = 1 / 11&lt;/p&gt;

&lt;p&gt;を str1 と str2 の類似度と定義します。あとで知りましたが、Jaccard 係数というそうです。&lt;/p&gt;

&lt;p&gt;この類似度の定義だと &amp;#8216;hogehoge&amp;#8217; と &amp;#8216;hogeh&amp;#8217; の類似度が 1 になってしまうといった欠点があります（繰り返しに弱い）。しかし繰り返しを含んだ単語の出現頻度はそれほど高くない気がするのでとりあえずこれでやってみることにしました。&lt;/p&gt;

&lt;p&gt;実際の処理内容は以下のような感じです。&lt;/p&gt;

&lt;p&gt;(1) bi-gram の転置インデックスを前処理で作る&lt;/p&gt;

&lt;pre&gt;dict = [&#39;hoge&#39;, &#39;hage&#39;] とするとき、これの bi-gram による転置インデックスtdictは
tdict = {
    &#39;ho&#39;: [0],
    &#39;og&#39;: [0],
    &#39;ge&#39;: [0, 1],
    &#39;ha&#39;: [1],
    &#39;ag&#39;: [1]
}
となって、tdict[&#39;ge&#39;] とアクセスすると &#39;ge&#39; を bi-gram
として含む単語のインデックスの配列 [0, 1] を返す。
&lt;/pre&gt;

&lt;p&gt;(2) input (ツイート) が来たら、それを bi-gramize した集合の各要素について転置インデックスを引く&lt;/p&gt;

&lt;p&gt;(3) 転置インデックスを引いた時の戻り値（単語のインデックスの配列）それぞれに対して出現回数を数える&lt;/p&gt;

&lt;p&gt;擬似コードで書くとこんな感じです。&lt;/p&gt;

&lt;pre&gt;bigramize(input).forEach(function (one_bigram_element) {
    tdict[one_bigram_element].forEach(function (dict_index) {
        count[dict_index]++;
    });
});
&lt;/pre&gt;

&lt;p&gt;これが終了すると count[dict_index] には dict の dict_index 番目の文字列を bi-gramize した集合と input を bi-gramize した集合の共通部分の要素数が入るので、&lt;/p&gt;

&lt;pre&gt;count[dict_index] / (bigramize(input).length
                     + bigramize(dict[dict_index]).length
                     - count[dict_index])
&lt;/pre&gt;

&lt;p&gt;を計算すれば類似度が得られます。bigramize(input), bigramize(dict[dict_index]) はすでに求められているのでこの部分は定数で計算できます。Node.js (V8) のハッシュテーブルの foreach がどんな実装かは知りませんが、仮に同じ要素数分詰まっている密な配列を舐める時間と同じとすればナイーブに辞書の全要素を舐めるより速く計算可能です。&lt;/p&gt;

&lt;p&gt;O( (入力文字列長) * (転置インデックスの平均配列長 (tdict[hoge]の長さの平均)) )&lt;/p&gt;

&lt;p&gt;ソースコードは &lt;a href=&#34;https://github.com/arcturu/kinmoza_quotes/blob/master/qs_server.js&#34;&gt;https://github.com/arcturu/kinmoza_quotes/blob/master/qs_server.js&lt;/a&gt; の search() です。&lt;/p&gt;

&lt;p&gt;TODO: bi-gramize で位置情報使うように改善する&lt;/p&gt;

&lt;p&gt;（もっといいアルゴリズム、教えてください(&amp;gt;_&amp;lt;)）&lt;/p&gt;

&lt;h3 id=&#34;twitter-streaming-api-rest-api&#34;&gt;twitter streaming api / REST api&lt;/h3&gt;

&lt;h4 id=&#34;初期設定&#34;&gt;初期設定&lt;/h4&gt;

&lt;p&gt;コンソールで&lt;/p&gt;

&lt;pre&gt;npm install twitter
&lt;/pre&gt;

&lt;p&gt;スクリプトで&lt;/p&gt;

&lt;pre lang=&#34;js&#34;&gt;var twitter = require(&#39;twitter&#39;);
bot = new twitter({
    &#39;consumer_key&#39;: &#39;**************&#39;,
    &#39;consumer_secret&#39;: &#39;**************&#39;,
    &#39;access_token_key&#39;: &#39;**************&#39;,
    &#39;access_token_secret&#39;: &#39;**************&#39;
});
&lt;/pre&gt;

&lt;h4 id=&#34;全世界のツイートを垂れ流してもらう&#34;&gt;全世界のツイートを垂れ流してもらう&lt;/h4&gt;

&lt;pre lang=&#34;js&#34;&gt;bot.stream(&#39;statuses/sample&#39;, function (stream) {
    stream.on(&#39;data&#39;, function (data) {
        console.log(data); // json でツイートのメタデータ全部吐く
        console.log(data.text); // ツイートの内容だけ
    });
});
&lt;/pre&gt;

&lt;h4 id=&#34;自分のタイムラインを取得&#34;&gt;自分のタイムラインを取得&lt;/h4&gt;

&lt;pre lang=&#34;js&#34;&gt;bot.stream(&#39;user&#39;, function (stream) {
    stream.on(&#39;data&#39;, function (data) {
        console.log(data);
    });
});
&lt;/pre&gt;

&lt;h4 id=&#34;ツイート&#34;&gt;ツイート&lt;/h4&gt;

&lt;pre lang=&#34;js&#34;&gt;bot.post(&#39;statuses/update&#39;, {
    status: tweet, // ツイート文言
    in_reply_to_status_id: status_id // リプライ先のツイートの id
}, function (e, data) {
        console.log(e); // エラーメッセージ（あれば）
        console.log(data); // ツイートのメタデータ
    });
});
&lt;/pre&gt;

&lt;pre&gt;bot.post(&#39;statuses/hogehoge&#39;, options, function ()...
&lt;/pre&gt;

&lt;p&gt;のhogehoge, optionsには&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://dev.twitter.com/rest/public&#34;&gt;https://dev.twitter.com/rest/public&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;の対応する文言を入れればいいみたいです。例えば &lt;a href=&#34;https://dev.twitter.com/rest/reference/get/statuses/retweets/%3Aid&#34;&gt;GET statuses/retweets/:id&lt;/a&gt; を叩きたいときは&lt;/p&gt;

&lt;pre&gt;bot.post(&#39;statuses/retweets&#39;, {
    id: id_to_be_retweeted
}, callback);
&lt;/pre&gt;

&lt;p&gt;とします。&lt;/p&gt;

&lt;h3 id=&#34;ソースコード&#34;&gt;ソースコード&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/arcturu/kinmoza_quotes&#34;&gt;https://github.com/arcturu/kinmoza_quotes&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;twio.js が twitter streaming api を使っている twitter とのやりとり用のサーバで、qs_server.js が検索サーバです。cli.js で簡単に検索することもできます。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
